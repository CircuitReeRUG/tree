{% extends 'base.html' %}
{% block head %}
<style>
    body {
        margin: 0;
        overflow: hidden;
    }

    #editor-page {
        display: flex;
        flex-direction: column;
        height: 100vh;
    }

    #editor-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 16px;
        background-color: #2D2D2D;
        border-bottom: 1px solid #BAB9B7;
    }

    #editor-toolbar-left {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #editor-container {
        flex: 1;
        position: relative;
        overflow: hidden;
    }

    #editor {
        width: 100%;
        height: 100%;
    }

    #editor-toolbar button,
    #editor-toolbar input[type="text"] {
        padding: 8px 14px;
        border-radius: 4px;
        border: 1px solid #BAB9B7;
        font-size: 14px;
        background-color: #1E1E1E;
        color: #CCCCCC;
    }

    #editor-toolbar input[type="text"]::placeholder {
        color: #858585;
    }

    #editor-toolbar button.primary {
        background-color: #F6921D;
        color: #FFFFFF;
        border-color: #F6921D;
        font-weight: bold;
        cursor: pointer;
    }

    #editor-toolbar button.primary:hover {
        background-color: #e07e14;
    }

    #message {
        min-height: 20px;
        font-size: 14px;
        color: #CCCCCC;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js" crossorigin="anonymous"
    referrerpolicy="no-referrer"></script>
{% endblock %}
{% block content %}
<div id="editor-page">
    <div id="editor-toolbar">
        <div id="editor-toolbar-left">
            <form id="editor-form" method="POST" action="/editor"
                style="display:flex; gap:8px; align-items:center;">
                <input type="hidden" name="editor_code" id="editor_code">
                <input type="text" name="username" placeholder="Username (optional)" maxlength="32">
                <button type="submit" class="primary">Run on Tree</button>
            </form>
        </div>
        <div id="message"></div>
    </div>
    <div id="editor-container">
        <div id="editor"></div>
    </div>
</div>
<script>
    // Configure Monaco loader
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });
    let editor;
    require(['vs/editor/editor.main'], function () {
        // Register custom Python types for the exposed functions
        const exposedFunctions = `
def getLEDCount() -> int:
    """Returns the total number of LEDs in the tree."""
    pass

def setLEDs(new_leds: list[tuple[int, int, int, int]]) -> bool:
    """
    Set the LED states for the entire tree.
    
    Args:
        new_leds: List of tuples (R, G, B, Luminance) where each value is 0-255
    
    Returns:
        True if successful
    
    Raises:
        ValueError: If list size doesn't match tree size or invalid LED values
    """
    pass

def clearLEDs() -> None:
    """Clear all LEDs (set to off/black)."""
    pass

def sleep(seconds: float) -> None:
    """
    Sleep for the specified number of seconds (max 10s).
    
    Args:
        seconds: Number of seconds to sleep (max 10)
    
    Raises:
        ValueError: If seconds > 10
    """
    pass

SIZE: int  # Total number of LEDs in the tree
`;

        // Configure Python language features with autocomplete
        monaco.languages.registerCompletionItemProvider('python', {
            provideCompletionItems: (model, position) => {
                const suggestions = [
                    {
                        label: 'getLEDCount',
                        kind: monaco.languages.CompletionItemKind.Function,
                        insertText: 'getLEDCount()',
                        documentation: 'Returns the total number of LEDs in the tree.\n\nReturns:\n  int: Number of LEDs',
                        detail: '() -> int'
                    },
                    {
                        label: 'setLEDs',
                        kind: monaco.languages.CompletionItemKind.Function,
                        insertText: 'setLEDs(${1:led_states})',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        documentation: 'Set LED states for the entire tree.\n\nArgs:\n  new_leds: List of (R, G, B, Luminance) tuples where each value is 0-255\n\nReturns:\n  bool: True if successful\n\nRaises:\n  ValueError: If list size doesn\'t match tree size',
                        detail: '(new_leds: list[tuple[int, int, int, int]]) -> bool'
                    },
                    {
                        label: 'clearLEDs',
                        kind: monaco.languages.CompletionItemKind.Function,
                        insertText: 'clearLEDs()',
                        documentation: 'Clear all LEDs (set to off/black).',
                        detail: '() -> None'
                    },
                    {
                        label: 'sleep',
                        kind: monaco.languages.CompletionItemKind.Function,
                        insertText: 'sleep(${1:seconds})',
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        documentation: 'Sleep for the specified number of seconds (max 10s).\n\nArgs:\n  seconds: Number of seconds to sleep (max 10)\n\nRaises:\n  ValueError: If seconds > 10',
                        detail: '(seconds: float) -> None'
                    },
                ];
                return { suggestions };
            }
        });

        // Add hover provider for documentation
        monaco.languages.registerHoverProvider('python', {
            provideHover: (model, position) => {
                const word = model.getWordAtPosition(position);
                if (!word) return null;

                const hoverDocs = {
                    'getLEDCount': {
                        contents: [
                            { value: '```python\ndef getLEDCount() -> int\n```' },
                            { value: 'Returns the total number of LEDs in the tree.' }
                        ]
                    },
                    'setLEDs': {
                        contents: [
                            { value: '```python\ndef setLEDs(new_leds: list[tuple[int, int, int, int]]) -> bool\n```' },
                            { value: 'Set LED states for the entire tree.\n\n**Args:**\n- `new_leds`: List of (R, G, B, Luminance) tuples where each value is 0-255\n\n**Returns:** True if successful\n\n**Raises:** ValueError if list size doesn\'t match tree size' }
                        ]
                    },
                    'clearLEDs': {
                        contents: [
                            { value: '```python\ndef clearLEDs() -> None\n```' },
                            { value: 'Clear all LEDs (set to off/black).' }
                        ]
                    },
                    'sleep': {
                        contents: [
                            { value: '```python\ndef sleep(seconds: float) -> None\n```' },
                            { value: 'Sleep for the specified number of seconds (max 10s).\n\n**Args:**\n- `seconds`: Number of seconds to sleep (max 10)\n\n**Raises:** ValueError if seconds > 10' }
                        ]
                    },
                };

                if (hoverDocs[word.word]) {
                    return { contents: hoverDocs[word.word].contents };
                }
                return null;
            }
        });

        function validatePythonCode(model) {
            const code = model.getValue();
            const markers = [];

            // Check for common issues with exposed functions
            const lines = code.split('\n');

            lines.forEach((line, idx) => {

                // Check setLEDs usage
                if (line.includes('setLEDs(')) {
                    // Warn if not using getLEDCount
                    if (!code.includes('getLEDCount()')) {
                        const col = line.indexOf('setLEDs') + 1;
                        markers.push({
                            severity: monaco.MarkerSeverity.Warning,
                            startLineNumber: idx + 1,
                            startColumn: col,
                            endLineNumber: idx + 1,
                            endColumn: col + 7,
                            message: 'Consider using getLEDCount() to ensure correct LED list size'
                        });
                    }

                    // Check tuple format
                    const tupleMatch = line.match(/\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
                    if (tupleMatch) {
                        const values = [parseInt(tupleMatch[1]), parseInt(tupleMatch[2]), parseInt(tupleMatch[3]), parseInt(tupleMatch[4])];
                        values.forEach((val, i) => {
                            if (val > 255) {
                                markers.push({
                                    severity: monaco.MarkerSeverity.Error,
                                    startLineNumber: idx + 1,
                                    startColumn: 1,
                                    endLineNumber: idx + 1,
                                    endColumn: line.length + 1,
                                    message: `LED ${['R', 'G', 'B', 'Luminance'][i]} value ${val} exceeds maximum of 255`
                                });
                            }
                        });
                    }
                }

                // Check sleep duration
                const sleepMatch = line.match(/sleep\s*\(\s*(\d+(?:\.\d+)?)\s*\)/);
                if (sleepMatch) {
                    const duration = parseFloat(sleepMatch[1]);
                    if (duration > 10) {
                        const col = line.indexOf('sleep') + 1;
                        markers.push({
                            severity: monaco.MarkerSeverity.Error,
                            startLineNumber: idx + 1,
                            startColumn: col,
                            endLineNumber: idx + 1,
                            endColumn: line.length + 1,
                            message: `sleep duration ${duration}s exceeds maximum of 10s`
                        });
                    }
                }

                // Check for common Python syntax errors
                if (line.trim().startsWith('if ') && !line.trim().endsWith(':')) {
                    markers.push({
                        severity: monaco.MarkerSeverity.Error,
                        startLineNumber: idx + 1,
                        startColumn: 1,
                        endLineNumber: idx + 1,
                        endColumn: line.length + 1,
                        message: 'Missing colon at end of if statement'
                    });
                }

                if (line.trim().startsWith('for ') && !line.trim().endsWith(':')) {
                    markers.push({
                        severity: monaco.MarkerSeverity.Error,
                        startLineNumber: idx + 1,
                        startColumn: 1,
                        endLineNumber: idx + 1,
                        endColumn: line.length + 1,
                        message: 'Missing colon at end of for statement'
                    });
                }

                if (line.trim().startsWith('def ') && !line.trim().endsWith(':')) {
                    markers.push({
                        severity: monaco.MarkerSeverity.Error,
                        startLineNumber: idx + 1,
                        startColumn: 1,
                        endLineNumber: idx + 1,
                        endColumn: line.length + 1,
                        message: 'Missing colon at end of function definition'
                    });
                }
            });

            monaco.editor.setModelMarkers(model, 'python', markers);
        }

        // Default template code
        const defaultCode = `# CircuitRee LED Programming Template
# Available functions: getLEDCount(), setLEDs(), clearLEDs(), sleep()

# Example: Simple color fade
num_leds = getLEDCount()

# Create a list of LED states (R, G, B, Luminance)
# Each value must be between 0-255
leds = [(255, 0, 0, 100)] * num_leds  # Red color, 100 brightness

# Set all LEDs to red
setLEDs(leds)
sleep(1)

# Change to green
leds = [(0, 255, 0, 100)] * num_leds
setLEDs(leds)
sleep(1)

# Change to blue
leds = [(0, 0, 255, 100)] * num_leds
setLEDs(leds)
sleep(1)

# Clear all LEDs
clearLEDs()

`;

        // Load saved code from localStorage or use default
        const savedCode = localStorage.getItem('editorCode') || defaultCode;

        // Create the editor
        editor = monaco.editor.create(document.getElementById('editor'), {
            value: savedCode,
            language: 'python',
            theme: 'vs-dark',
            automaticLayout: true,
            minimap: { enabled: false },
            fontSize: 14,
            tabSize: 4,
            insertSpaces: true,
            suggestOnTriggerCharacters: true,
            quickSuggestions: {
                other: true,
                comments: false,
                strings: false
            },
            parameterHints: {
                enabled: true
            },
            suggest: {
                snippetsPreventQuickSuggestions: false
            }
        });

        // Autosave functionality with debouncing
        let saveTimeout;
        editor.onDidChangeModelContent(() => {
            validatePythonCode(editor.getModel());
            
            // Debounced autosave (save 1 second after typing stops)
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                const code = editor.getValue();
                localStorage.setItem('editorCode', code);
            }, 1000);
        });

        validatePythonCode(editor.getModel());
    });

    // Intercept form submit and send editor contents
    document.getElementById('editor-form').addEventListener('submit', function (e) {
        e.preventDefault();
        if (!editor) return;
        
        const code = editor.getValue();
        const username = document.querySelector('input[name="username"]').value || 'anonymous';
        const messageDiv = document.getElementById('message');
        
        // Send as JSON
        fetch('/editor', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                editor_code: code,
                username: username
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                messageDiv.textContent = 'Error: ' + data.error;
                messageDiv.style.color = '#FF6B6B';
            } else if (data.job_hash) {
                setTimeout(() => {
                    window.location.href = '/job/' + data.job_hash;
                }, 1000);
            }
        })
        .catch(error => {
            messageDiv.textContent = 'Network error: ' + error.message;
            messageDiv.style.color = '#FF6B6B';
        });
    });

</script>
{% include "help.html" %}

{% endblock %}